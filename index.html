<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radar Cidadão - Santa Cruz do Capibaribe</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Leaflet CSS (para o mapa) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Chart.js (para os gráficos) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Font Awesome (Ícones) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <!-- Fonte Inter -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <style>
        body { font-family: 'Inter', sans-serif; }
        #mapa { height: 500px; border-radius: 0.5rem; background-color: #f3f4f6; }
        .pin-vermelho { color: #dc2626; } /* red-600 */
        .pin-amarelo { color: #f59e0b; } /* amber-500 */
        .pin-verde { color: #16a34a; }  /* green-600 */
        .scc-bg-blue { background-color: #312e81; }
        .scc-bg-green { background-color: #15803d; }
        .scc-text-blue { color: #312e81; }
        .scc-text-green { color: #15803d; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
        .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">

    <div class="max-w-7xl mx-auto p-4 md:p-8">
        
        <!-- Cabeçalho -->
        <header class="scc-bg-blue p-6 rounded-lg shadow-lg mb-8">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-3xl md:text-4xl font-bold text-white">Radar Cidadão</h1>
                    <p class="text-sm md:text-base text-indigo-200">Santa Cruz do Capibaribe</p>
                </div>
                <div class="flex shadow-sm">
                    <div class="w-8 h-5 bg-white rounded-l-sm"></div>
                    <div class="w-8 h-5 scc-bg-green rounded-r-sm"></div>
                </div>
            </div>
        </header>

        <!-- Feedback (Carregando / Erro) -->
        <div id="feedback-msg" class="mb-6 p-4 rounded-lg text-center font-medium bg-blue-100 text-blue-700 animate-pulse">
            <i class="fas fa-spinner fa-spin mr-2"></i>
            A ligar à base de dados...
        </div>

        <!-- Métricas Principais -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
            <div class="bg-white p-6 rounded-lg shadow-md flex items-center justify-between">
                <div>
                    <span class="text-sm font-medium text-gray-500">Total de Ocorrências</span>
                    <p id="total-metric" class="text-3xl font-bold scc-text-blue">...</p>
                </div>
                <i class="fas fa-bullhorn fa-2x text-gray-300"></i>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-md flex items-center justify-between">
                <div>
                    <span class="text-sm font-medium text-gray-500">Pendentes</span>
                    <p id="pendente-metric" class="text-3xl font-bold text-red-600">...</p>
                </div>
                <i class="fas fa-clock fa-2x text-gray-300"></i>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-md flex items-center justify-between">
                <div>
                    <span class="text-sm font-medium text-gray-500">Resolvidos</span>
                    <p id="resolvido-metric" class="text-3xl font-bold scc-text-green">...</p>
                </div>
                <i class="fas fa-check-circle fa-2x text-gray-300"></i>
            </div>
        </div>

        <!-- Mapa e Gráficos -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="lg:col-span-2 bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 scc-text-blue">Mapa de Ocorrências</h2>
                <div id="mapa"></div>
            </div>
            <div class="space-y-6">
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-xl font-semibold mb-4 scc-text-blue">Status Geral</h2>
                    <canvas id="grafico-status"></canvas>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-xl font-semibold mb-4 scc-text-blue">Tipos de Ocorrência</h2>
                    <canvas id="grafico-tipos"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- SDKs do Firebase (Módulos v9) -->
    <script type="module">
        // Importa as funções necessárias
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getFirestore, collection, onSnapshot, query } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";

        // --- A TUA CONFIGURAÇÃO DO FIREBASE ---
        const firebaseConfig = {
          apiKey: "AIzaSyDM0CvmTJMIbQudEndIJYO55r0qz30V-Sw",
          authDomain: "cidadao-scc.firebaseapp.com",
          projectId: "cidadao-scc",
          storageBucket: "cidadao-scc.firebasestorage.app",
          messagingSenderId: "542851157019",
          appId: "1:542851157019:web:60e9b0eb957b5a3425fcbe",
          measurementId: "G-XYKDFXRPFX"
        };

        // --- Inicializa o Firebase e o Firestore ---
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- Elementos do DOM (movidos para dentro do 'onload') ---
        let feedbackMsg, totalMetric, pendenteMetric, resolvidoMetric;
        let mapa = null;
        let layerGrupo = null;
        let graficoStatus = null;
        let graficoTipos = null;

        // --- Variáveis Globais para dados e filtros ---
        let todosOsDados = []; // Onde guardamos TODOS os dados vindos do Firebase
        let filtrosStatus = { // O estado atual dos nossos filtros
            'Pendente': true,
            'Em Andamento': true,
            'Resolvido': true
        };
        let filtrosTipo = {}; // NOVO: Filtro para os tipos de ocorrência
        let coresTipos = {}; // NOVO: Para guardar as cores originais das barras

        // Cores
        const corAzulSCC = '#312e81';
        const corVerdeSCC = '#15803d';
        const corAmarelaSCC = '#f59e0b';
        const corVermelhaStatus = '#dc2626';
        const corCinzaFiltro = '#d1d5db'; // gray-300

        // --- 1. Função de Feedback ---
        function mostrarFeedback(tipo, mensagem) {
            if (!feedbackMsg) feedbackMsg = document.getElementById('feedback-msg');
            feedbackMsg.classList.remove('hidden', 'bg-blue-100', 'text-blue-700', 'bg-red-100', 'text-red-700', 'bg-green-100', 'text-green-700', 'animate-pulse');
            if (tipo === 'loading') {
                feedbackMsg.classList.add('bg-blue-100', 'text-blue-700', 'animate-pulse');
            } else if (tipo === 'error') {
                feedbackMsg.classList.add('bg-red-100', 'text-red-700');
            } else { // info ou success
                feedbackMsg.classList.add('bg-green-100', 'text-green-700');
            }
            feedbackMsg.innerHTML = mensagem; 
            feedbackMsg.classList.remove('hidden');
        }

        
        // --- 2. Função Centralizada de Atualização ---
        // Esta função é chamada sempre que um filtro muda
        function aplicarFiltrosEAtualizarDashboard() {
            
            // 1. Aplicar AMBOS os filtros aos dados principais
            const dadosFiltrados = todosOsDados.filter(item => {
                const status = item.status || 'Pendente'; 
                const tipo = item.tipo || null;
                
                // Se o tipo não existir no filtro (é novo), default to true
                if (tipo && filtrosTipo[tipo] === undefined) {
                    filtrosTipo[tipo] = true; 
                }

                return filtrosStatus[status] && filtrosTipo[tipo]; 
            });

            // 2. Atualizar o Mapa
            atualizarMapaPins(dadosFiltrados);

            // 3. Atualizar as Métricas
            atualizarMetricas(dadosFiltrados);
            
            // 4. Atualizar os Gráficos
            // O gráfico de Status NÃO é atualizado (como pediste)
            // Mas o gráfico de Tipos PRECISA ser atualizado para refletir o filtro de Status
            atualizarGraficoTipos(dadosFiltrados);
        }

        // --- 3. Funções de Atualização Específicas ---

        function atualizarMapaPins(dados) {
            if (!layerGrupo) inicializarMapa(); 
            layerGrupo.clearLayers();

            const iconPendente = L.divIcon({ html: '<i class="fas fa-map-pin fa-3x pin-vermelho"></i>', className: '', iconSize: [32, 32], iconAnchor: [16, 32] });
            const iconEmAndamento = L.divIcon({ html: '<i class="fas fa-map-pin fa-3x pin-amarelo"></i>', className: '', iconSize: [32, 32], iconAnchor: [16, 32] });
            const iconResolvido = L.divIcon({ html: '<i class="fas fa-map-pin fa-3x pin-verde"></i>', className: '', iconSize: [32, 32], iconAnchor: [16, 32] });

            dados.forEach(item => {
                try {
                    const lat = parseFloat(item.latitude);
                    const lon = parseFloat(item.longitude);
                    if (isNaN(lat) || isNaN(lon)) return; 

                    let icon = iconPendente;
                    if (item.status === 'Resolvido') icon = iconResolvido;
                    else if (item.status === 'Em Andamento') icon = iconEmAndamento;
                    
                    const marcador = L.marker([lat, lon], { icon: icon });
                    
                    marcador.bindPopup(`
                        <strong class="scc-text-blue">${item.tipo || 'N/D'}</strong><br>
                        <strong>Status:</strong> ${item.status || 'N/D'}<br>
                        <strong>Data:</strong> ${item.timestamp ? item.timestamp.toDate().toLocaleDateString('pt-BR') : 'N/D'}<br>
                        <strong>Descrição:</strong> ${item.descricao || 'N/D'}
                    `);
                    layerGrupo.addLayer(marcador);
                } catch(e) { console.warn("Erro ao adicionar pino:", e); }
            });
        }

        function atualizarMetricas(dados) {
            let total = dados.length;
            let pendentes = 0;
            let resolvidos = 0;
            let emAndamento = 0; 
            
            dados.forEach(item => {
                if (item.status === 'Resolvido') { resolvidos++; }
                else if (item.status === 'Em Andamento') { emAndamento++; }
                else { pendentes++; }
            });

            totalMetric.textContent = total;
            pendenteMetric.textContent = pendentes;
            resolvidoMetric.textContent = resolvidos;
        }

        // --- 4. Funções de Criação dos Gráficos (Chamadas só uma vez) ---

        function criarGraficoStatus(dados) {
            let pendentes = 0;
            let resolvidos = 0;
            let emAndamento = 0; 
            
            dados.forEach(item => {
                if (item.status === 'Resolvido') { resolvidos++; }
                else if (item.status === 'Em Andamento') { emAndamento++; }
                else { pendentes++; }
            });

            const ctxStatus = document.getElementById('grafico-status').getContext('2d');
            if (graficoStatus) graficoStatus.destroy(); 
            graficoStatus = new Chart(ctxStatus, {
                type: 'doughnut',
                data: {
                    labels: ['Pendente', 'Em Andamento', 'Resolvido'],
                    datasets: [{
                        label: 'Status',
                        data: [pendentes, emAndamento, resolvidos],
                        backgroundColor: [corVermelhaStatus, corAmarelaSCC, corVerdeSCC],
                        hoverOffset: 4
                    }]
                },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: true,
                    // CORRIGIDO: Lógica de clique manual
                    plugins: {
                        legend: {
                            onClick: (e, legendItem, legend) => {
                                // 1. Inverte manualmente o estado 'hidden'
                                legendItem.hidden = !legendItem.hidden;
                                
                                // 2. Atualiza o nosso objeto de filtro
                                filtrosStatus[legendItem.text] = !legendItem.hidden; 
                                
                                // 3. Força o gráfico a atualizar-se (para aplicar o tracejado E esconder/mostrar a fatia)
                                legend.chart.update(); 
                                
                                // 4. Manda atualizar o resto do dashboard
                                aplicarFiltrosEAtualizarDashboard();
                            }
                        }
                    }
                }
            });
        }

        function criarGraficoTipos(dados) {
            let tipos = {};
            const coresBase = [corAzulSCC, corVerdeSCC, corAmarelaSCC, corVermelhaStatus, '#6366f1', '#ec4899'];
            
            dados.forEach((item, index) => {
                if (item.tipo) { 
                    tipos[item.tipo] = (tipos[item.tipo] || 0) + 1; 
                    if (!coresTipos[item.tipo]) { // Guarda a cor original
                        coresTipos[item.tipo] = coresBase[Object.keys(coresTipos).length % coresBase.length];
                    }
                    if (filtrosTipo[item.tipo] === undefined) { // Popula o filtro
                        filtrosTipo[item.tipo] = true;
                    }
                }
            });

            const labelsTipos = Object.keys(tipos);
            const backgroundColors = labelsTipos.map(label => {
                return filtrosTipo[label] ? coresTipos[label] : corCinzaFiltro;
            });

            const ctxTipos = document.getElementById('grafico-tipos').getContext('2d');
            if (graficoTipos) graficoTipos.destroy(); 
            graficoTipos = new Chart(ctxTipos, {
                type: 'bar',
                data: {
                    labels: labelsTipos,
                    datasets: [{
                        label: 'Nº de Ocorrências',
                        data: Object.values(tipos),
                        backgroundColor: backgroundColors,
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: true, indexAxis: 'y',
                    scales: { 
                        y: { beginAtZero: true },
                        x: { ticks: { stepSize: (dados.length > 0 && dados.length < 10) ? 1 : undefined } } 
                    },
                    plugins: {
                        legend: { display: false }
                    },
                    onClick: (e, elements, chart) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const label = chart.data.labels[index];
                            
                            // 1. Inverte o filtro
                            filtrosTipo[label] = !filtrosTipo[label];
                            
                            // 2. Manda atualizar o resto do dashboard
                            aplicarFiltrosEAtualizarDashboard();
                            
                            // 3. Atualiza as cores DESTE gráfico
                            chart.data.datasets[0].backgroundColor = chart.data.labels.map(l => {
                                return filtrosTipo[l] ? coresTipos[l] : corCinzaFiltro;
                            });
                            chart.update();
                        }
                    }
                }
            });
        }
        
        // NOVO: Função para atualizar o gráfico de tipos (baseado nos filtros de status)
        function atualizarGraficoTipos(dadosFiltrados) {
            if (!graficoTipos) return; // Se o gráfico não foi criado ainda
            
            let tipos = {};
            dadosFiltrados.forEach(item => {
                if (item.tipo) { 
                    tipos[item.tipo] = (tipos[item.tipo] || 0) + 1; 
                }
            });
            
            // Atualiza os dados do gráfico de tipos
            graficoTipos.data.labels = Object.keys(tipos);
            graficoTipos.data.datasets[0].data = Object.values(tipos);
            graficoTipos.data.datasets[0].backgroundColor = graficoTipos.data.labels.map(l => {
                return filtrosTipo[l] ? coresTipos[l] : corCinzaFiltro;
            });
            graficoTipos.update();
        }

        // --- 5. Inicializar Mapa (SÓ CORRE UMA VEZ) ---
        function inicializarMapa() {
            if (mapa) return; 
            const sccCoords = [-7.954, -36.204]; // Coordenadas de Santa Cruz do Capibaribe
            mapa = L.map('mapa').setView(sccCoords, 14);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(mapa);
            layerGrupo = L.layerGroup().addTo(mapa); 
        }

        // --- 6. LIGAR AO FIREBASE QUANDO A PÁGINA CARREGAR ---
        window.onload = () => {
            // Agora temos a certeza que os elementos existem
            feedbackMsg = document.getElementById('feedback-msg');
            totalMetric = document.getElementById('total-metric');
            pendenteMetric = document.getElementById('pendente-metric');
            resolvidoMetric = document.getElementById('resolvido-metric');
            
            try {
                inicializarMapa(); // Inicializa o mapa
                
                const q = query(collection(db, "ocorrencias"));
                
                // 'onSnapshot' é o "ouvinte" em tempo real
                onSnapshot(q, (snapshot) => {
                    // 1. Atualiza a nossa base de dados global
                    todosOsDados = []; 
                    snapshot.forEach((doc) => {
                        todosOsDados.push(doc.data()); 
                    });

                    // 2. Cria os gráficos pela primeira vez com os dados TOTAIS
                    criarGraficoStatus(todosOsDados);
                    criarGraficoTipos(todosOsDados);

                    // 3. Aplica os filtros (default) e atualiza o resto
                    aplicarFiltrosEAtualizarDashboard(); 

                    // Mostra feedback de sucesso
                    if (todosOsDados.length === 0) {
                        mostrarFeedback('info', 'Nenhuma ocorrência encontrada.');
                    } else {
                        feedbackMsg.classList.add('hidden'); // Esconde o feedback
                    }

                }, (error) => {
                    console.error("Erro ao ligar ao Firestore: ", error);
                    mostrarFeedback('error', `Não foi possível ligar à base de dados. <br><small>Verifique as regras do Firestore.</small>`);
                });

            } catch(e) {
                console.error("Erro geral:", e);
                mostrarFeedback('error', 'Ocorreu um erro ao carregar a aplicação.');
            }
        }; // Fim do window.onload
    </script>
</body>
</html>








